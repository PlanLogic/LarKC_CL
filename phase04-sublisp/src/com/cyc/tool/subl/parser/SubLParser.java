/* Generated By:JavaCC: Do not edit this line. SubLParser.java */
package com.cyc.tool.subl.parser;

import com.cyc.tool.subl.jrtl.nativeCode.type.symbol.SubLPackage;
import com.cyc.tool.subl.jrtl.nativeCode.type.core.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.exception.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.number.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.operator.*;
import com.cyc.tool.subl.jrtl.nativeCode.type.symbol.*;
import com.cyc.tool.subl.jrtl.nativeCode.subLisp.*;
import java.io.*;

/**
* <P>This class implements a parser for the SubL grammar. This file
* was automatically generated with javacc based on the file: "subl.jj".
* The SubL parser files can be regenerated by calling:
* /opt/local/pkg/JavaCC/bin/javacc subl.jj
* JavaCC 3.2 was used in the creation of the source files.
*
* Note:
* SubL supports these built-in Common Lisp datatypes:
*   Numbers (fixnum, double), Symbols, Lists, Vector, Character,
*   Strings, Hashtables, Stream, Function, Packages(limited support: ),
*   Structures
* SubL does not support these Common Lisp datatypes:
*   Readtables, Multi-dimensional arrays, Pathnames, Random-states, Lambda-Expressions or Closures
* 
* @version $Id: SubLParser.java 127267 2009-02-26 22:38:02Z tbrussea $
* @author Tony Brusseau
*
* <p>Copyright 2005-6 Cycorp, Inc., use controled by license terms only.
*/
 public class SubLParser implements CommonSymbols, SubLParserConstants {

   private String currentPackage = "SUBLISP";

   /**
    * The parser program.
    *
    * @param args currently ignored.
    */
   public static void main(String[] args) {
     SubLParser parser = new SubLParser(System.in);
     try {
       parser.termList(true, true);
     } catch (Exception e) {
       System.err.println(e);
     }
   }

/********************* Parser ********************/
  public SubLList termList(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 SubLList val = NIL;
 SubLObject curTerm = null;
 boolean shouldFeaturizeOut = false;
    eatWhiteSpace(eatInitialWS);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
      case PACKAGE_SEPARATOR:
      case VECTOR_PREFIX:
      case FUNCTION_QUOTE:
      case QUOTE_CHAR:
      case BACK_QUOTE:
      case SPLICING_UNQUOTE:
      case UNQUOTE:
      case UNINTERNED_SYMBOL_PREFIX:
      case READ_TIME_EVALUATION:
      case WS:
      case FLOAT1:
      case FLOAT2:
      case DECIMAL_INTEGER:
      case BASED_INTEGER:
      case NAMED_CHARACTER:
      case CHARACTER:
      case STRING:
      case CASE_SENSITIVE_SUBL_SYMBOL_NAME:
      case SUBL_SYMBOL_NAME:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      curTerm = term(false, false);
    val = SubLObjectFactory.makeCons(curTerm, val);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_2;
        }
        jj_consume_token(WS);
      }
    }
    eof(requireEOF);
   {if (true) return val.toList().reverse(true).toList();}
    throw new Error("Missing return statement in function");
  }

  public SubLObject term(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 SubLObject curTerm = null;
 SubLList currentQuotes = SubLNil.NIL;
 boolean doReadTimeEvaluation = false;
    eatWhiteSpace(eatInitialWS);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FUNCTION_QUOTE:
      case QUOTE_CHAR:
      case BACK_QUOTE:
      case SPLICING_UNQUOTE:
      case UNQUOTE:
      case READ_TIME_EVALUATION:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTE_CHAR:
        jj_consume_token(QUOTE_CHAR);
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_4;
          }
          jj_consume_token(WS);
        }
                                  currentQuotes = manageQuote(SubLQuote.QUOTE_SYMBOL, currentQuotes);
        break;
      case BACK_QUOTE:
        jj_consume_token(BACK_QUOTE);
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_5;
          }
          jj_consume_token(WS);
        }
                                   currentQuotes = manageQuote(SubLQuote.BACK_QUOTE_SYMBOL, currentQuotes);
        break;
      case FUNCTION_QUOTE:
        jj_consume_token(FUNCTION_QUOTE);
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[5] = jj_gen;
            break label_6;
          }
          jj_consume_token(WS);
        }
                                       currentQuotes = manageQuote(SubLQuote.FUNCTION_QUOTE_SYMBOL, currentQuotes);
        break;
      case SPLICING_UNQUOTE:
        jj_consume_token(SPLICING_UNQUOTE);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[6] = jj_gen;
            break label_7;
          }
          jj_consume_token(WS);
        }
                                         currentQuotes = manageQuote(SubLQuote.SPLICING_UNQUOTE_SYMBOL, currentQuotes);
        break;
      case UNQUOTE:
        jj_consume_token(UNQUOTE);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[7] = jj_gen;
            break label_8;
          }
          jj_consume_token(WS);
        }
                                currentQuotes = manageQuote(SubLQuote.UNQUOTE_SYMBOL, currentQuotes);
        break;
      case READ_TIME_EVALUATION:
        jj_consume_token(READ_TIME_EVALUATION);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WS:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_9;
          }
          jj_consume_token(WS);
        }
                                              doReadTimeEvaluation = true;
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
    case WS:
      curTerm = form(false, false);
      break;
    case VECTOR_PREFIX:
      curTerm = vector(false, false);
      break;
    case PACKAGE_SEPARATOR:
    case UNINTERNED_SYMBOL_PREFIX:
    case FLOAT1:
    case FLOAT2:
    case DECIMAL_INTEGER:
    case BASED_INTEGER:
    case NAMED_CHARACTER:
    case CHARACTER:
    case STRING:
    case CASE_SENSITIVE_SUBL_SYMBOL_NAME:
    case SUBL_SYMBOL_NAME:
      curTerm = atom(false, false);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    eof(requireEOF);
   SubLObject result = processQuotes(curTerm, currentQuotes);
   {if (true) return doReadTimeEvaluation ? result.eval(SubLEnvironment.currentEnvironment()) : result;}
    throw new Error("Missing return statement in function");
  }

  public SubLObject processQuotes(SubLObject quotedObject, SubLList quoteList) throws ParseException {
  SubLList result = null;
  SubLList currentQuote = SubLNil.NIL;
  SubLQuote theQuote = null;
  if (quoteList == SubLNil.NIL) { {if (true) return quotedObject;} }
  if (quoteList.size() == 1) {
    theQuote = (SubLQuote)quoteList.first();
    if ((theQuote == SubLQuote.FUNCTION_QUOTE_SYMBOL) && (!quotedObject.isSymbol())) {
      {if (true) throw new ParseException("Got invalid quote: " + theQuote + " for term: " + quotedObject);}
    }
    quoteList = quoteList.push(quotedObject);
    quoteList = quoteList.reverse(true).toList();
    {if (true) return quoteList;}
  }
  result = SubLObjectFactory.makeCons(quotedObject, SubLNil.NIL);
  for (int i = 0, size = quoteList.size(); i < size; i++) {
    theQuote = (SubLQuote)quoteList.get(i);
    result = SubLObjectFactory.makeCons(result, result);
  }
  {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  public SubLList manageQuote(SubLQuote quoteType, SubLList currentQuotes) throws ParseException {
  currentQuotes = currentQuotes.push(quoteType);
  {if (true) return currentQuotes;}
    throw new Error("Missing return statement in function");
  }

  public SubLList form(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 SubLList result = null;
 SubLList contents = null;
 SubLObject dottedItem = null;
    eatWhiteSpace(eatInitialWS);
    jj_consume_token(OPEN_PAREN);
    contents = termList(false, true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      jj_consume_token(DOT);
      label_10:
      while (true) {
        jj_consume_token(WS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WS:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_10;
        }
      }
      dottedItem = term(false, false);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_11;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(CLOSE_PAREN);
                                      result = contents;
    eof(requireEOF);
   if ((contents != null) && (dottedItem != null)) {
      contents.setDottedElement(dottedItem);
   }
   if (result.size() == 0) {
      {if (true) return NIL;}
   }
   {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  public SubLVector vector(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 SubLList result = null;
    eatWhiteSpace(eatInitialWS);
    jj_consume_token(VECTOR_PREFIX);
    result = termList(false, true);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_12;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(CLOSE_PAREN);
    eof(requireEOF);
   {if (true) return SubLObjectFactory.makeVector(result);}
    throw new Error("Missing return statement in function");
  }

  public SubLObject atom(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 SubLObject atom;
    eatWhiteSpace(eatInitialWS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WS:
    case NAMED_CHARACTER:
    case CHARACTER:
      atom = character(false, false);
      break;
    case STRING:
      atom = string(false, false);
      break;
    case FLOAT1:
    case FLOAT2:
    case DECIMAL_INTEGER:
    case BASED_INTEGER:
      atom = number(false, false);
      break;
    case PACKAGE_SEPARATOR:
    case UNINTERNED_SYMBOL_PREFIX:
    case CASE_SENSITIVE_SUBL_SYMBOL_NAME:
    case SUBL_SYMBOL_NAME:
      atom = symbol(false, false);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    eof(requireEOF);
   {if (true) return atom;}
    throw new Error("Missing return statement in function");
  }

//internal use only
  public String symbolName() throws ParseException {
  String val = null;
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUBL_SYMBOL_NAME:
      t = jj_consume_token(SUBL_SYMBOL_NAME);
                                 val = t.image;
      break;
    case CASE_SENSITIVE_SUBL_SYMBOL_NAME:
      t = jj_consume_token(CASE_SENSITIVE_SUBL_SYMBOL_NAME);
                                                val = t.image;
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if ((val == null) || (val.equals(""))) { {if (true) return currentPackage;} } else { {if (true) return val;} }
    throw new Error("Missing return statement in function");
  }

  public SubLString string(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 Token t = null;
    eatWhiteSpace(eatInitialWS);
    t = jj_consume_token(STRING);
    eof(requireEOF);
   {if (true) return SubLObjectFactory.makeString(t.image.substring(1, t.image.length()-1));}
    throw new Error("Missing return statement in function");
  }

  public SubLNumber number(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 SubLNumber val = null;
 Token t = null;
 String baseOrFPStr = "";
    eatWhiteSpace(eatInitialWS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_INTEGER:
      t = jj_consume_token(DECIMAL_INTEGER);
        val = SubLObjectFactory.makeIntegralNumber((t.image.startsWith("+") ? t.image.substring(1) : t.image), 10);
      break;
    case BASED_INTEGER:
      t = jj_consume_token(BASED_INTEGER);
                                   val = SubLObjectFactory.makeBasedIntegralNumber(t.image);
      break;
    case FLOAT1:
    case FLOAT2:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT1:
        t = jj_consume_token(FLOAT1);
        break;
      case FLOAT2:
        t = jj_consume_token(FLOAT2);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     baseOrFPStr = t.image.toLowerCase();
     val = SubLObjectFactory.makeDouble(t.image.toLowerCase().replaceAll("\\p{Alpha}", "e"));
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    eof(requireEOF);
   {if (true) return val;}
    throw new Error("Missing return statement in function");
  }

  public SubLSymbol symbol(boolean requireEOF, boolean eatInitialWS) throws ParseException {
  Token t = null;
  String symbolOrPackageName = SubLPackage.KEYWORD_PACKAGE.getName();
  String symName = "";
  boolean isInterned = true;
  SubLSymbol symbol = null;
    eatWhiteSpace(eatInitialWS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNINTERNED_SYMBOL_PREFIX:
      jj_consume_token(UNINTERNED_SYMBOL_PREFIX);
      symbolOrPackageName = symbolName();
                                                                         isInterned = false;
      break;
    case PACKAGE_SEPARATOR:
      jj_consume_token(PACKAGE_SEPARATOR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PACKAGE_SEPARATOR:
        jj_consume_token(PACKAGE_SEPARATOR);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      symName = symbolName();
      break;
    case CASE_SENSITIVE_SUBL_SYMBOL_NAME:
    case SUBL_SYMBOL_NAME:
      symbolOrPackageName = symbolName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PACKAGE_SEPARATOR:
        jj_consume_token(PACKAGE_SEPARATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PACKAGE_SEPARATOR:
          jj_consume_token(PACKAGE_SEPARATOR);
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        symName = symbolName();
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if ((symName == null) || ("".equals(symName))) {
      symbol = SubLObjectFactory.makeSymbol(symbolOrPackageName, isInterned ? SubLPackage.getCurrentPackage() : null);
    } else {
      symbol = SubLObjectFactory.makeSymbol(symName, symbolOrPackageName);
    }
    eof(requireEOF);
   {if (true) return symbol;}
    throw new Error("Missing return statement in function");
  }

  public SubLCharacter character(boolean requireEOF, boolean eatInitialWS) throws ParseException {
 SubLCharacter val = null;
 Token t = null;
    eatWhiteSpace(eatInitialWS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NAMED_CHARACTER:
      t = jj_consume_token(NAMED_CHARACTER);
                             val = SubLObjectFactory.makeChar(t.image);
      break;
    case CHARACTER:
      t = jj_consume_token(CHARACTER);
                         val = SubLObjectFactory.makeChar(t.image);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    eof(requireEOF);
   {if (true) return val;}
    throw new Error("Missing return statement in function");
  }

  public void eatWhiteSpace(boolean shouldEatWS) throws ParseException {
      if (!shouldEatWS) { {if (true) return;} }
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_13;
      }
      jj_consume_token(WS);
    }
  }

  public void eof(boolean requireEOF) throws ParseException {
     if (!requireEOF) {if (true) return;}
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WS:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_14;
      }
      jj_consume_token(WS);
    }
    jj_consume_token(0);
  }

  public SubLParserTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  private int[] jj_la1 = new int[26];
  private int[] jj_la1_0 = {0x6e0067ea,0x2000000,0x47c0,0x2000000,0x2000000,0x2000000,0x2000000,0x2000000,0x2000000,0x47c0,0x6e00202a,0x2000000,0x800,0x2000000,0x2000000,0x6e002008,0x0,0xc000000,0x6c000000,0x8,0x8,0x8,0x2008,0x0,0x2000000,0x2000000,};
  private int[] jj_la1_1 = {0x4c06,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c06,0x0,0x0,0x0,0x0,0x4c06,0x4800,0x0,0x0,0x0,0x0,0x0,0x4800,0x6,0x0,0x0,};

  public SubLParser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new SubLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public SubLParser(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new SubLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public SubLParser(SubLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  public void ReInit(SubLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[47];
    for (int i = 0; i < 47; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 47; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  public void enable_tracing() {
  }

  public void disable_tracing() {
  }

 }
